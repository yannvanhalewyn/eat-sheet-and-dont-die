(ns sheet-bucket.models.sheet
  (:require [datomic.api :as d]
            [clojure.walk :refer [postwalk]]))

(def BLANK_SHEET
  {:db/id "new-sheet"
   :sheet/title "Title"
   :sheet/artist "Artist"
   :sheet/sections {:section/title "Intro"
                    :coll/position 0
                    :section/rows {:coll/position 0
                                   :row/bars {:coll/position 0
                                              :bar/chords {:coll/position 0
                                                           :chord/value ""}}}}})

(defn- sort-children [node]
  (if (and (sequential? node) (map? (first node)))
    (sort-by :coll/position node)
    node))

(defn- resolve-enums [keys db]
  (fn [node]
    (if (and (coll? node) (keys (first node)))
      (update node 1 #(:db/ident (d/entity db (:db/id %))))
      node)))

(defn find [db-conn sheet-id]
  (let [db (d/db db-conn)]
    (postwalk
      (comp sort-children (resolve-enums #{:attachment/type} db))
      (d/pull db '[*] sheet-id))))

(defn create! [db-conn owner-id]
  (let [res (d/transact db-conn
              [BLANK_SHEET {:db/id owner-id :playlist/sheets "new-sheet"}])]
    (d/pull (:db-after @res) '[*] (get-in @res [:tempids "new-sheet"]))))


(defn diff->tx
  "Takes a list of diffpaths (usually generated by `shared.diffp) and
  returns a list of datomic transactions to persist that diff."
  [diff-list sheet-eid]
  (map
    #(if-let [retract (:removed %)]
       [:db.fn/retractEntity (:db/id retract)]
       (let [new-entity (or (:added %) (:new-value %))]
         (if (nil? new-entity)
           (flatten [:db/retract (take-last 2 (:path %)) (:old-value %)])
           (reduce
             (fn [children [id ref-key]]
               {:db/id id
                ref-key children})
             new-entity
             (reverse (partition-all 2 (cons sheet-eid (:path %))))))))
    diff-list))
